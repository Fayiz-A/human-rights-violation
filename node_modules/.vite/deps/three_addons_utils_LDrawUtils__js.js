import {
  BufferAttribute,
  BufferGeometry,
  Group,
  LineSegments,
  Matrix3,
  Mesh
} from "./chunk-UMN7JHZN.js";

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
function mergeBufferGeometries(geometries, useGroups = false) {
  const isIndexed = geometries[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries[0].morphTargetsRelative;
  const mergedGeometry = new BufferGeometry();
  let offset = 0;
  for (let i = 0; i < geometries.length; ++i) {
    const geometry = geometries[i];
    let attributesCount = 0;
    if (isIndexed !== (geometry.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (const name in geometry.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0)
        attributes[name] = [];
      attributes[name].push(geometry.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geometry.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (const name in geometry.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0)
        morphAttributes[name] = [];
      morphAttributes[name].push(geometry.morphAttributes[name]);
    }
    if (useGroups) {
      let count;
      if (isIndexed) {
        count = geometry.index.count;
      } else if (geometry.attributes.position !== void 0) {
        count = geometry.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count, i);
      offset += count;
    }
  }
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    for (let i = 0; i < geometries.length; ++i) {
      const index = geometries[i].index;
      for (let j = 0; j < index.count; ++j) {
        mergedIndex.push(index.getX(j) + indexOffset);
      }
      indexOffset += geometries[i].attributes.position.count;
    }
    mergedGeometry.setIndex(mergedIndex);
  }
  for (const name in attributes) {
    const mergedAttribute = mergeBufferAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (const name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0)
      break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i = 0; i < numMorphTargets; ++i) {
      const morphAttributesToMerge = [];
      for (let j = 0; j < morphAttributes[name].length; ++j) {
        morphAttributesToMerge.push(morphAttributes[name][j][i]);
      }
      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
}
function mergeBufferAttributes(attributes) {
  let TypedArray;
  let itemSize;
  let normalized;
  let arrayLength = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.isInterleavedBufferAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.");
      return null;
    }
    if (TypedArray === void 0)
      TypedArray = attribute.array.constructor;
    if (TypedArray !== attribute.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0)
      itemSize = attribute.itemSize;
    if (itemSize !== attribute.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0)
      normalized = attribute.normalized;
    if (normalized !== attribute.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attribute.array.length;
  }
  const array = new TypedArray(arrayLength);
  let offset = 0;
  for (let i = 0; i < attributes.length; ++i) {
    array.set(attributes[i].array, offset);
    offset += attributes[i].array.length;
  }
  return new BufferAttribute(array, itemSize, normalized);
}

// node_modules/three/examples/jsm/utils/LDrawUtils.js
var LDrawUtils = class {
  static mergeObject(object) {
    function extractGroup(geometry, group, elementSize, isConditionalLine) {
      const newGeometry = new BufferGeometry();
      const originalPositions = geometry.getAttribute("position").array;
      const originalNormals = elementSize === 3 ? geometry.getAttribute("normal").array : null;
      const numVertsGroup = Math.min(group.count, Math.floor(originalPositions.length / 3) - group.start);
      const vertStart = group.start * 3;
      const vertEnd = (group.start + numVertsGroup) * 3;
      const positions = originalPositions.subarray(vertStart, vertEnd);
      const normals = originalNormals !== null ? originalNormals.subarray(vertStart, vertEnd) : null;
      newGeometry.setAttribute("position", new BufferAttribute(positions, 3));
      if (normals !== null)
        newGeometry.setAttribute("normal", new BufferAttribute(normals, 3));
      if (isConditionalLine) {
        const controlArray0 = geometry.getAttribute("control0").array.subarray(vertStart, vertEnd);
        const controlArray1 = geometry.getAttribute("control1").array.subarray(vertStart, vertEnd);
        const directionArray = geometry.getAttribute("direction").array.subarray(vertStart, vertEnd);
        newGeometry.setAttribute("control0", new BufferAttribute(controlArray0, 3, false));
        newGeometry.setAttribute("control1", new BufferAttribute(controlArray1, 3, false));
        newGeometry.setAttribute("direction", new BufferAttribute(directionArray, 3, false));
      }
      return newGeometry;
    }
    function addGeometry(mat, geometry, geometries) {
      const geoms = geometries[mat.uuid];
      if (!geoms) {
        geometries[mat.uuid] = {
          mat,
          arr: [geometry]
        };
      } else {
        geoms.arr.push(geometry);
      }
    }
    function permuteAttribute(attribute, elemSize) {
      if (!attribute)
        return;
      const verts = attribute.array;
      const numVerts = Math.floor(verts.length / 3);
      let offset = 0;
      for (let i = 0; i < numVerts; i++) {
        const x = verts[offset];
        const y = verts[offset + 1];
        const z = verts[offset + 2];
        verts[offset] = verts[offset + 3];
        verts[offset + 1] = verts[offset + 4];
        verts[offset + 2] = verts[offset + 5];
        verts[offset + 3] = x;
        verts[offset + 4] = y;
        verts[offset + 5] = z;
        offset += elemSize * 3;
      }
    }
    const meshGeometries = {};
    const linesGeometries = {};
    const condLinesGeometries = {};
    object.updateMatrixWorld(true);
    const normalMatrix = new Matrix3();
    object.traverse((c) => {
      if (c.isMesh | c.isLineSegments) {
        const elemSize = c.isMesh ? 3 : 2;
        const geometry = c.geometry.clone();
        const matrixIsInverted = c.matrixWorld.determinant() < 0;
        if (matrixIsInverted) {
          permuteAttribute(geometry.attributes.position, elemSize);
          permuteAttribute(geometry.attributes.normal, elemSize);
        }
        geometry.applyMatrix4(c.matrixWorld);
        if (c.isConditionalLine) {
          geometry.attributes.control0.applyMatrix4(c.matrixWorld);
          geometry.attributes.control1.applyMatrix4(c.matrixWorld);
          normalMatrix.getNormalMatrix(c.matrixWorld);
          geometry.attributes.direction.applyNormalMatrix(normalMatrix);
        }
        const geometries = c.isMesh ? meshGeometries : c.isConditionalLine ? condLinesGeometries : linesGeometries;
        if (Array.isArray(c.material)) {
          for (const groupIndex in geometry.groups) {
            const group = geometry.groups[groupIndex];
            const mat = c.material[group.materialIndex];
            const newGeometry = extractGroup(geometry, group, elemSize, c.isConditionalLine);
            addGeometry(mat, newGeometry, geometries);
          }
        } else {
          addGeometry(c.material, geometry, geometries);
        }
      }
    });
    const mergedObject = new Group();
    const meshMaterialsIds = Object.keys(meshGeometries);
    for (const meshMaterialsId of meshMaterialsIds) {
      const meshGeometry = meshGeometries[meshMaterialsId];
      const mergedGeometry = mergeBufferGeometries(meshGeometry.arr);
      mergedObject.add(new Mesh(mergedGeometry, meshGeometry.mat));
    }
    const linesMaterialsIds = Object.keys(linesGeometries);
    for (const linesMaterialsId of linesMaterialsIds) {
      const lineGeometry = linesGeometries[linesMaterialsId];
      const mergedGeometry = mergeBufferGeometries(lineGeometry.arr);
      mergedObject.add(new LineSegments(mergedGeometry, lineGeometry.mat));
    }
    const condLinesMaterialsIds = Object.keys(condLinesGeometries);
    for (const condLinesMaterialsId of condLinesMaterialsIds) {
      const condLineGeometry = condLinesGeometries[condLinesMaterialsId];
      const mergedGeometry = mergeBufferGeometries(condLineGeometry.arr);
      const condLines = new LineSegments(mergedGeometry, condLineGeometry.mat);
      condLines.isConditionalLine = true;
      mergedObject.add(condLines);
    }
    mergedObject.userData.constructionStep = 0;
    mergedObject.userData.numConstructionSteps = 1;
    return mergedObject;
  }
};
export {
  LDrawUtils
};
//# sourceMappingURL=three_addons_utils_LDrawUtils__js.js.map
